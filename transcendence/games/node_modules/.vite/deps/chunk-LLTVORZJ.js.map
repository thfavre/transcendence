{
  "version": 3,
  "sources": ["../../three/examples/jsm/lines/LineMaterial.js"],
  "sourcesContent": ["/**\r\n * parameters = {\r\n *  color: <hex>,\r\n *  linewidth: <float>,\r\n *  dashed: <boolean>,\r\n *  dashScale: <float>,\r\n *  dashSize: <float>,\r\n *  dashOffset: <float>,\r\n *  gapSize: <float>,\r\n *  resolution: <Vector2>, // to be set by renderer\r\n * }\r\n */\r\n\r\nimport {\r\n\tShaderLib,\r\n\tShaderMaterial,\r\n\tUniformsLib,\r\n\tUniformsUtils,\r\n\tVector2\r\n} from 'three';\r\n\r\n\r\nUniformsLib.line = {\r\n\r\n\tworldUnits: { value: 1 },\r\n\tlinewidth: { value: 1 },\r\n\tresolution: { value: new Vector2( 1, 1 ) },\r\n\tdashOffset: { value: 0 },\r\n\tdashScale: { value: 1 },\r\n\tdashSize: { value: 1 },\r\n\tgapSize: { value: 1 } // todo FIX - maybe change to totalSize\r\n\r\n};\r\n\r\nShaderLib[ 'line' ] = {\r\n\r\n\tuniforms: UniformsUtils.merge( [\r\n\t\tUniformsLib.common,\r\n\t\tUniformsLib.fog,\r\n\t\tUniformsLib.line\r\n\t] ),\r\n\r\n\tvertexShader:\r\n\t/* glsl */`\r\n\t\t#include <common>\r\n\t\t#include <color_pars_vertex>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\t\t#include <clipping_planes_pars_vertex>\r\n\r\n\t\tuniform float linewidth;\r\n\t\tuniform vec2 resolution;\r\n\r\n\t\tattribute vec3 instanceStart;\r\n\t\tattribute vec3 instanceEnd;\r\n\r\n\t\tattribute vec3 instanceColorStart;\r\n\t\tattribute vec3 instanceColorEnd;\r\n\r\n\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\tvarying vec4 worldPos;\r\n\t\t\tvarying vec3 worldStart;\r\n\t\t\tvarying vec3 worldEnd;\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#else\r\n\r\n\t\t\tvarying vec2 vUv;\r\n\r\n\t\t#endif\r\n\r\n\t\t#ifdef USE_DASH\r\n\r\n\t\t\tuniform float dashScale;\r\n\t\t\tattribute float instanceDistanceStart;\r\n\t\t\tattribute float instanceDistanceEnd;\r\n\t\t\tvarying float vLineDistance;\r\n\r\n\t\t#endif\r\n\r\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\r\n\r\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\r\n\r\n\t\t\t// conservative estimate of the near plane\r\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\r\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\r\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\r\n\r\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\r\n\r\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#ifdef USE_COLOR\r\n\r\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\r\n\t\t\t\tvUv = uv;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat aspect = resolution.x / resolution.y;\r\n\r\n\t\t\t// camera space\r\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\r\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\r\n\r\n\t\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\t\tworldStart = start.xyz;\r\n\t\t\t\tworldEnd = end.xyz;\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvUv = uv;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\r\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\r\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\r\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\r\n\r\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\r\n\r\n\t\t\tif ( perspective ) {\r\n\r\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\r\n\r\n\t\t\t\t\ttrimSegment( start, end );\r\n\r\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\r\n\r\n\t\t\t\t\ttrimSegment( end, start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// clip space\r\n\t\t\tvec4 clipStart = projectionMatrix * start;\r\n\t\t\tvec4 clipEnd = projectionMatrix * end;\r\n\r\n\t\t\t// ndc space\r\n\t\t\tvec3 ndcStart = clipStart.xyz / clipStart.w;\r\n\t\t\tvec3 ndcEnd = clipEnd.xyz / clipEnd.w;\r\n\r\n\t\t\t// direction\r\n\t\t\tvec2 dir = ndcEnd.xy - ndcStart.xy;\r\n\r\n\t\t\t// account for clip-space aspect ratio\r\n\t\t\tdir.x *= aspect;\r\n\t\t\tdir = normalize( dir );\r\n\r\n\t\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\t\tvec3 worldDir = normalize( end.xyz - start.xyz );\r\n\t\t\t\tvec3 tmpFwd = normalize( mix( start.xyz, end.xyz, 0.5 ) );\r\n\t\t\t\tvec3 worldUp = normalize( cross( worldDir, tmpFwd ) );\r\n\t\t\t\tvec3 worldFwd = cross( worldDir, worldUp );\r\n\t\t\t\tworldPos = position.y < 0.5 ? start: end;\r\n\r\n\t\t\t\t// height offset\r\n\t\t\t\tfloat hw = linewidth * 0.5;\r\n\t\t\t\tworldPos.xyz += position.x < 0.0 ? hw * worldUp : - hw * worldUp;\r\n\r\n\t\t\t\t// don't extend the line if we're rendering dashes because we\r\n\t\t\t\t// won't be rendering the endcaps\r\n\t\t\t\t#ifndef USE_DASH\r\n\r\n\t\t\t\t\t// cap extension\r\n\t\t\t\t\tworldPos.xyz += position.y < 0.5 ? - hw * worldDir : hw * worldDir;\r\n\r\n\t\t\t\t\t// add width to the box\r\n\t\t\t\t\tworldPos.xyz += worldFwd * hw;\r\n\r\n\t\t\t\t\t// endcaps\r\n\t\t\t\t\tif ( position.y > 1.0 || position.y < 0.0 ) {\r\n\r\n\t\t\t\t\t\tworldPos.xyz -= worldFwd * 2.0 * hw;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t\t// project the worldpos\r\n\t\t\t\tvec4 clip = projectionMatrix * worldPos;\r\n\r\n\t\t\t\t// shift the depth of the projected points so the line\r\n\t\t\t\t// segments overlap neatly\r\n\t\t\t\tvec3 clipPose = ( position.y < 0.5 ) ? ndcStart : ndcEnd;\r\n\t\t\t\tclip.z = clipPose.z * clip.w;\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\tvec2 offset = vec2( dir.y, - dir.x );\r\n\t\t\t\t// undo aspect ratio adjustment\r\n\t\t\t\tdir.x /= aspect;\r\n\t\t\t\toffset.x /= aspect;\r\n\r\n\t\t\t\t// sign flip\r\n\t\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\r\n\r\n\t\t\t\t// endcaps\r\n\t\t\t\tif ( position.y < 0.0 ) {\r\n\r\n\t\t\t\t\toffset += - dir;\r\n\r\n\t\t\t\t} else if ( position.y > 1.0 ) {\r\n\r\n\t\t\t\t\toffset += dir;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// adjust for linewidth\r\n\t\t\t\toffset *= linewidth;\r\n\r\n\t\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\r\n\t\t\t\toffset /= resolution.y;\r\n\r\n\t\t\t\t// select end\r\n\t\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\r\n\r\n\t\t\t\t// back to clip space\r\n\t\t\t\toffset *= clip.w;\r\n\r\n\t\t\t\tclip.xy += offset;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tgl_Position = clip;\r\n\r\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <clipping_planes_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}\r\n\t\t`,\r\n\r\n\tfragmentShader:\r\n\t/* glsl */`\r\n\t\tuniform vec3 diffuse;\r\n\t\tuniform float opacity;\r\n\t\tuniform float linewidth;\r\n\r\n\t\t#ifdef USE_DASH\r\n\r\n\t\t\tuniform float dashOffset;\r\n\t\t\tuniform float dashSize;\r\n\t\t\tuniform float gapSize;\r\n\r\n\t\t#endif\r\n\r\n\t\tvarying float vLineDistance;\r\n\r\n\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\tvarying vec4 worldPos;\r\n\t\t\tvarying vec3 worldStart;\r\n\t\t\tvarying vec3 worldEnd;\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tvarying vec2 vUv;\r\n\r\n\t\t\t#endif\r\n\r\n\t\t#else\r\n\r\n\t\t\tvarying vec2 vUv;\r\n\r\n\t\t#endif\r\n\r\n\t\t#include <common>\r\n\t\t#include <color_pars_fragment>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\t\t#include <clipping_planes_pars_fragment>\r\n\r\n\t\tvec2 closestLineToLine(vec3 p1, vec3 p2, vec3 p3, vec3 p4) {\r\n\r\n\t\t\tfloat mua;\r\n\t\t\tfloat mub;\r\n\r\n\t\t\tvec3 p13 = p1 - p3;\r\n\t\t\tvec3 p43 = p4 - p3;\r\n\r\n\t\t\tvec3 p21 = p2 - p1;\r\n\r\n\t\t\tfloat d1343 = dot( p13, p43 );\r\n\t\t\tfloat d4321 = dot( p43, p21 );\r\n\t\t\tfloat d1321 = dot( p13, p21 );\r\n\t\t\tfloat d4343 = dot( p43, p43 );\r\n\t\t\tfloat d2121 = dot( p21, p21 );\r\n\r\n\t\t\tfloat denom = d2121 * d4343 - d4321 * d4321;\r\n\r\n\t\t\tfloat numer = d1343 * d4321 - d1321 * d4343;\r\n\r\n\t\t\tmua = numer / denom;\r\n\t\t\tmua = clamp( mua, 0.0, 1.0 );\r\n\t\t\tmub = ( d1343 + d4321 * ( mua ) ) / d4343;\r\n\t\t\tmub = clamp( mub, 0.0, 1.0 );\r\n\r\n\t\t\treturn vec2( mua, mub );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <clipping_planes_fragment>\r\n\r\n\t\t\t#ifdef USE_DASH\r\n\r\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\r\n\r\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tfloat alpha = opacity;\r\n\r\n\t\t\t#ifdef WORLD_UNITS\r\n\r\n\t\t\t\t// Find the closest points on the view ray and the line segment\r\n\t\t\t\tvec3 rayEnd = normalize( worldPos.xyz ) * 1e5;\r\n\t\t\t\tvec3 lineDir = worldEnd - worldStart;\r\n\t\t\t\tvec2 params = closestLineToLine( worldStart, worldEnd, vec3( 0.0, 0.0, 0.0 ), rayEnd );\r\n\r\n\t\t\t\tvec3 p1 = worldStart + lineDir * params.x;\r\n\t\t\t\tvec3 p2 = rayEnd * params.y;\r\n\t\t\t\tvec3 delta = p1 - p2;\r\n\t\t\t\tfloat len = length( delta );\r\n\t\t\t\tfloat norm = len / linewidth;\r\n\r\n\t\t\t\t#ifndef USE_DASH\r\n\r\n\t\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\r\n\r\n\t\t\t\t\t\tfloat dnorm = fwidth( norm );\r\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 0.5 - dnorm, 0.5 + dnorm, norm );\r\n\r\n\t\t\t\t\t#else\r\n\r\n\t\t\t\t\t\tif ( norm > 0.5 ) {\r\n\r\n\t\t\t\t\t\t\tdiscard;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t#endif\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t#else\r\n\r\n\t\t\t\t#ifdef USE_ALPHA_TO_COVERAGE\r\n\r\n\t\t\t\t\t// artifacts appear on some hardware if a derivative is taken within a conditional\r\n\t\t\t\t\tfloat a = vUv.x;\r\n\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\t\t\t\tfloat len2 = a * a + b * b;\r\n\t\t\t\t\tfloat dlen = fwidth( len2 );\r\n\r\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\t\t\t\t\talpha = 1.0 - smoothstep( 1.0 - dlen, 1.0 + dlen, len2 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#else\r\n\r\n\t\t\t\t\tif ( abs( vUv.y ) > 1.0 ) {\r\n\r\n\t\t\t\t\t\tfloat a = vUv.x;\r\n\t\t\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\r\n\t\t\t\t\t\tfloat len2 = a * a + b * b;\r\n\r\n\t\t\t\t\t\tif ( len2 > 1.0 ) discard;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t#endif\r\n\r\n\t\t\t#endif\r\n\r\n\t\t\tvec4 diffuseColor = vec4( diffuse, alpha );\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\t\t\t#include <color_fragment>\r\n\r\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, alpha );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <colorspace_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\t\t\t#include <premultiplied_alpha_fragment>\r\n\r\n\t\t}\r\n\t\t`\r\n};\r\n\r\nclass LineMaterial extends ShaderMaterial {\r\n\r\n\tconstructor( parameters ) {\r\n\r\n\t\tsuper( {\r\n\r\n\t\t\ttype: 'LineMaterial',\r\n\r\n\t\t\tuniforms: UniformsUtils.clone( ShaderLib[ 'line' ].uniforms ),\r\n\r\n\t\t\tvertexShader: ShaderLib[ 'line' ].vertexShader,\r\n\t\t\tfragmentShader: ShaderLib[ 'line' ].fragmentShader,\r\n\r\n\t\t\tclipping: true // required for clipping support\r\n\r\n\t\t} );\r\n\r\n\t\tthis.isLineMaterial = true;\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n\tget color() {\r\n\r\n\t\treturn this.uniforms.diffuse.value;\r\n\r\n\t}\r\n\r\n\tset color( value ) {\r\n\r\n\t\tthis.uniforms.diffuse.value = value;\r\n\r\n\t}\r\n\r\n\tget worldUnits() {\r\n\r\n\t\treturn 'WORLD_UNITS' in this.defines;\r\n\r\n\t}\r\n\r\n\tset worldUnits( value ) {\r\n\r\n\t\tif ( value === true ) {\r\n\r\n\t\t\tthis.defines.WORLD_UNITS = '';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdelete this.defines.WORLD_UNITS;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tget linewidth() {\r\n\r\n\t\treturn this.uniforms.linewidth.value;\r\n\r\n\t}\r\n\r\n\tset linewidth( value ) {\r\n\r\n\t\tif ( ! this.uniforms.linewidth ) return;\r\n\t\tthis.uniforms.linewidth.value = value;\r\n\r\n\t}\r\n\r\n\tget dashed() {\r\n\r\n\t\treturn 'USE_DASH' in this.defines;\r\n\r\n\t}\r\n\r\n\tset dashed( value ) {\r\n\r\n\t\tif ( ( value === true ) !== this.dashed ) {\r\n\r\n\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( value === true ) {\r\n\r\n\t\t\tthis.defines.USE_DASH = '';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdelete this.defines.USE_DASH;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tget dashScale() {\r\n\r\n\t\treturn this.uniforms.dashScale.value;\r\n\r\n\t}\r\n\r\n\tset dashScale( value ) {\r\n\r\n\t\tthis.uniforms.dashScale.value = value;\r\n\r\n\t}\r\n\r\n\tget dashSize() {\r\n\r\n\t\treturn this.uniforms.dashSize.value;\r\n\r\n\t}\r\n\r\n\tset dashSize( value ) {\r\n\r\n\t\tthis.uniforms.dashSize.value = value;\r\n\r\n\t}\r\n\r\n\tget dashOffset() {\r\n\r\n\t\treturn this.uniforms.dashOffset.value;\r\n\r\n\t}\r\n\r\n\tset dashOffset( value ) {\r\n\r\n\t\tthis.uniforms.dashOffset.value = value;\r\n\r\n\t}\r\n\r\n\tget gapSize() {\r\n\r\n\t\treturn this.uniforms.gapSize.value;\r\n\r\n\t}\r\n\r\n\tset gapSize( value ) {\r\n\r\n\t\tthis.uniforms.gapSize.value = value;\r\n\r\n\t}\r\n\r\n\tget opacity() {\r\n\r\n\t\treturn this.uniforms.opacity.value;\r\n\r\n\t}\r\n\r\n\tset opacity( value ) {\r\n\r\n\t\tif ( ! this.uniforms ) return;\r\n\t\tthis.uniforms.opacity.value = value;\r\n\r\n\t}\r\n\r\n\tget resolution() {\r\n\r\n\t\treturn this.uniforms.resolution.value;\r\n\r\n\t}\r\n\r\n\tset resolution( value ) {\r\n\r\n\t\tthis.uniforms.resolution.value.copy( value );\r\n\r\n\t}\r\n\r\n\tget alphaToCoverage() {\r\n\r\n\t\treturn 'USE_ALPHA_TO_COVERAGE' in this.defines;\r\n\r\n\t}\r\n\r\n\tset alphaToCoverage( value ) {\r\n\r\n\t\tif ( ! this.defines ) return;\r\n\r\n\t\tif ( ( value === true ) !== this.alphaToCoverage ) {\r\n\r\n\t\t\tthis.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( value === true ) {\r\n\r\n\t\t\tthis.defines.USE_ALPHA_TO_COVERAGE = '';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tdelete this.defines.USE_ALPHA_TO_COVERAGE;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { LineMaterial };\r\n"],
  "mappings": ";;;;;;;;;AAsBA,YAAY,OAAO;AAAA,EAElB,YAAY,EAAE,OAAO,EAAE;AAAA,EACvB,WAAW,EAAE,OAAO,EAAE;AAAA,EACtB,YAAY,EAAE,OAAO,IAAI,QAAS,GAAG,CAAE,EAAE;AAAA,EACzC,YAAY,EAAE,OAAO,EAAE;AAAA,EACvB,WAAW,EAAE,OAAO,EAAE;AAAA,EACtB,UAAU,EAAE,OAAO,EAAE;AAAA,EACrB,SAAS,EAAE,OAAO,EAAE;AAAA;AAErB;AAEA,UAAW,MAAO,IAAI;AAAA,EAErB,UAAU,cAAc,MAAO;AAAA,IAC9B,YAAY;AAAA,IACZ,YAAY;AAAA,IACZ,YAAY;AAAA,EACb,CAAE;AAAA,EAEF;AAAA;AAAA,IACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqNV;AAAA;AAAA,IACU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgKX;AAEA,IAAM,eAAN,cAA2B,eAAe;AAAA,EAEzC,YAAa,YAAa;AAEzB,UAAO;AAAA,MAEN,MAAM;AAAA,MAEN,UAAU,cAAc,MAAO,UAAW,MAAO,EAAE,QAAS;AAAA,MAE5D,cAAc,UAAW,MAAO,EAAE;AAAA,MAClC,gBAAgB,UAAW,MAAO,EAAE;AAAA,MAEpC,UAAU;AAAA;AAAA,IAEX,CAAE;AAEF,SAAK,iBAAiB;AAEtB,SAAK,UAAW,UAAW;AAAA,EAE5B;AAAA,EAEA,IAAI,QAAQ;AAEX,WAAO,KAAK,SAAS,QAAQ;AAAA,EAE9B;AAAA,EAEA,IAAI,MAAO,OAAQ;AAElB,SAAK,SAAS,QAAQ,QAAQ;AAAA,EAE/B;AAAA,EAEA,IAAI,aAAa;AAEhB,WAAO,iBAAiB,KAAK;AAAA,EAE9B;AAAA,EAEA,IAAI,WAAY,OAAQ;AAEvB,QAAK,UAAU,MAAO;AAErB,WAAK,QAAQ,cAAc;AAAA,IAE5B,OAAO;AAEN,aAAO,KAAK,QAAQ;AAAA,IAErB;AAAA,EAED;AAAA,EAEA,IAAI,YAAY;AAEf,WAAO,KAAK,SAAS,UAAU;AAAA,EAEhC;AAAA,EAEA,IAAI,UAAW,OAAQ;AAEtB,QAAK,CAAE,KAAK,SAAS;AAAY;AACjC,SAAK,SAAS,UAAU,QAAQ;AAAA,EAEjC;AAAA,EAEA,IAAI,SAAS;AAEZ,WAAO,cAAc,KAAK;AAAA,EAE3B;AAAA,EAEA,IAAI,OAAQ,OAAQ;AAEnB,QAAO,UAAU,SAAW,KAAK,QAAS;AAEzC,WAAK,cAAc;AAAA,IAEpB;AAEA,QAAK,UAAU,MAAO;AAErB,WAAK,QAAQ,WAAW;AAAA,IAEzB,OAAO;AAEN,aAAO,KAAK,QAAQ;AAAA,IAErB;AAAA,EAED;AAAA,EAEA,IAAI,YAAY;AAEf,WAAO,KAAK,SAAS,UAAU;AAAA,EAEhC;AAAA,EAEA,IAAI,UAAW,OAAQ;AAEtB,SAAK,SAAS,UAAU,QAAQ;AAAA,EAEjC;AAAA,EAEA,IAAI,WAAW;AAEd,WAAO,KAAK,SAAS,SAAS;AAAA,EAE/B;AAAA,EAEA,IAAI,SAAU,OAAQ;AAErB,SAAK,SAAS,SAAS,QAAQ;AAAA,EAEhC;AAAA,EAEA,IAAI,aAAa;AAEhB,WAAO,KAAK,SAAS,WAAW;AAAA,EAEjC;AAAA,EAEA,IAAI,WAAY,OAAQ;AAEvB,SAAK,SAAS,WAAW,QAAQ;AAAA,EAElC;AAAA,EAEA,IAAI,UAAU;AAEb,WAAO,KAAK,SAAS,QAAQ;AAAA,EAE9B;AAAA,EAEA,IAAI,QAAS,OAAQ;AAEpB,SAAK,SAAS,QAAQ,QAAQ;AAAA,EAE/B;AAAA,EAEA,IAAI,UAAU;AAEb,WAAO,KAAK,SAAS,QAAQ;AAAA,EAE9B;AAAA,EAEA,IAAI,QAAS,OAAQ;AAEpB,QAAK,CAAE,KAAK;AAAW;AACvB,SAAK,SAAS,QAAQ,QAAQ;AAAA,EAE/B;AAAA,EAEA,IAAI,aAAa;AAEhB,WAAO,KAAK,SAAS,WAAW;AAAA,EAEjC;AAAA,EAEA,IAAI,WAAY,OAAQ;AAEvB,SAAK,SAAS,WAAW,MAAM,KAAM,KAAM;AAAA,EAE5C;AAAA,EAEA,IAAI,kBAAkB;AAErB,WAAO,2BAA2B,KAAK;AAAA,EAExC;AAAA,EAEA,IAAI,gBAAiB,OAAQ;AAE5B,QAAK,CAAE,KAAK;AAAU;AAEtB,QAAO,UAAU,SAAW,KAAK,iBAAkB;AAElD,WAAK,cAAc;AAAA,IAEpB;AAEA,QAAK,UAAU,MAAO;AAErB,WAAK,QAAQ,wBAAwB;AAAA,IAEtC,OAAO;AAEN,aAAO,KAAK,QAAQ;AAAA,IAErB;AAAA,EAED;AAED;",
  "names": []
}
